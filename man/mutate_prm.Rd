% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/xtra_pars.R
\name{mutate_prm}
\alias{mutate_prm}
\title{Transform parameter values in place}
\usage{
mutate_prm(
  xpdb,
  ...,
  .autose = TRUE,
  .problem = NULL,
  .subprob = NULL,
  .method = NULL,
  .sesim = 1e+05,
  quiet
)
}
\arguments{
\item{xpdb}{<\code{xp_xtras}> object}

\item{...}{... <\code{\link[rlang:dyn-dots]{dynamic-dots}}> One or more formulae that
define transformations to parameters. RHS of formulas can be function or a
value. That value can be a function call like in \code{mutate()} (\code{the1~exp(the1)}).}

\item{.autose}{<\code{logical}> If a function is used for the transform then simulation
is used to transform the current SE to a new SE. Precision of this transformation
is dependent on \code{.sesim}. If parameter values are not assigned with a function,
this option will simply scale SE to maintain the same RSE.}

\item{.problem}{<\code{numeric}> Problem number to apply this relationship.}

\item{.subprob}{<\code{numeric}> Problem number to apply this relationship.}

\item{.method}{<\code{numeric}> Problem number to apply this relationship.}

\item{.sesim}{<\code{numeric}> Length of simulated \code{rnorm} vector for \code{.autose}.}

\item{quiet}{Silence extra output.}
}
\description{
Apply transformations to fitted parameter values.

As fitted, sometimes parameter values are not as easy to communicate, but
to transform them outside of the \code{xpose} ecosystem limits some available
features. To have the best experience, this function can update the
parameter values that are used by \code{xpose} \code{get_prm} functions. At this
time these transformations are not applied to \code{param} vars (\code{\link{list_vars}}), but that can
already be done with the \code{mutate} method.

This only works for theta parameters.

All valid mutations are applied sequentially, so a double call to \code{the2~the2^3}
will result in effectively \code{the2~the2^9}, for example.

RSE values will be updated at each transform. Any \emph{automatic} updates to SE will
be implemented before RSE is updated.
}
\examples{

vismo_pomod \%>\%
  # Function
  mutate_prm(THETA11~exp) \%>\%
  # Value (se will not be scaled); plogis = inverse logit
  mutate_prm(THETA12~plogis(THETA12)) \%>\%
  # For above, manually scale se (below is roughly how autose does it)
  # Note the qlogis since the previously piped function updates THETA12
  mutate_prm(se(THETA12)~sd(plogis(rnorm(1000,qlogis(THETA12),se(THETA12))))) \%>\%
  get_prm()


}
